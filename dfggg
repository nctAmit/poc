function buildSmoothGrid(positionsAll, colorsAll, indexMap, width, height, subdivisions = 4) {
    const outPositions = [];
    const outColors = [];
    const outIndices = [];

    let vertexIndex = 0;
    const step = 1 / subdivisions;

    for (let y = 0; y < height - 1; y++) {
        for (let x = 0; x < width - 1; x++) {
            const iTL = indexMap[y * width + x];
            const iTR = indexMap[y * width + (x + 1)];
            const iBL = indexMap[(y + 1) * width + x];
            const iBR = indexMap[(y + 1) * width + (x + 1)];

            if (iTL === -1 || iTR === -1 || iBL === -1 || iBR === -1) continue;

            // corner positions
            const pTL = [positionsAll[iTL * 3], positionsAll[iTL * 3 + 1], positionsAll[iTL * 3 + 2]];
            const pTR = [positionsAll[iTR * 3], positionsAll[iTR * 3 + 1], positionsAll[iTR * 3 + 2]];
            const pBL = [positionsAll[iBL * 3], positionsAll[iBL * 3 + 1], positionsAll[iBL * 3 + 2]];
            const pBR = [positionsAll[iBR * 3], positionsAll[iBR * 3 + 1], positionsAll[iBR * 3 + 2]];

            // simple color (average or TL only)
            const color = [
                colorsAll[iTL * 4],
                colorsAll[iTL * 4 + 1],
                colorsAll[iTL * 4 + 2],
                colorsAll[iTL * 4 + 3]
            ];

            // Build a (subdivisions+1) x (subdivisions+1) grid inside the cell
            const grid = [];
            for (let j = 0; j <= subdivisions; j++) {
                for (let i = 0; i <= subdivisions; i++) {
                    const u = i * step; // 0..1
                    const v = j * step; // 0..1

                    // bilinear interpolation of elevation & position
                    const xTop = [
                        pTL[0] * (1 - u) + pTR[0] * u,
                        pTL[1] * (1 - u) + pTR[1] * u,
                        pTL[2] * (1 - u) + pTR[2] * u
                    ];
                    const xBottom = [
                        pBL[0] * (1 - u) + pBR[0] * u,
                        pBL[1] * (1 - u) + pBR[1] * u,
                        pBL[2] * (1 - u) + pBR[2] * u
                    ];

                    const pos = [
                        xTop[0] * (1 - v) + xBottom[0] * v,
                        xTop[1] * (1 - v) + xBottom[1] * v,
                        xTop[2] * (1 - v) + xBottom[2] * v
                    ];

                    grid.push(vertexIndex);
                    outPositions.push(...pos);
                    outColors.push(...color);
                    vertexIndex++;
                }
            }

            // Triangulate subgrid
            for (let j = 0; j < subdivisions; j++) {
                for (let i = 0; i < subdivisions; i++) {
                    const i0 = grid[j * (subdivisions + 1) + i];
                    const i1 = grid[j * (subdivisions + 1) + (i + 1)];
                    const i2 = grid[(j + 1) * (subdivisions + 1) + i];
                    const i3 = grid[(j + 1) * (subdivisions + 1) + (i + 1)];

                    outIndices.push(i0, i1, i2);
                    outIndices.push(i2, i1, i3);
                }
            }
        }
    }

    return {
        outPositions: new Float64Array(outPositions),
        outColors: new Uint8Array(outColors),
        outIndices: new Uint32Array(outIndices)
    };
}
